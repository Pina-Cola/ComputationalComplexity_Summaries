\documentclass[a4]{scrartcl}

% \usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{scrlayer-scrpage}
\usepackage{float}
\pagestyle{scrheadings}
\clearscrheadfoot

\usepackage[backend=biber, maxbibnames=99]{biblatex}
\addbibresource{references.bib}

\setlength{\parindent}{0cm}

\usepackage{xcolor}


\geometry{
  paper=a4paper, % Change to letterpaper for US letter
  top=2cm, % Top margin
  bottom=1.5cm, % Bottom margin
  left=2cm, % Left margin
  right=3cm, % Right margin
}

\ohead{\\
Pina Kolling\\
piko0011}



\usepackage[framemethod=TikZ]{mdframed}

% Style %
\mdfdefinestyle{enviStyle}{
   innertopmargin = 10pt,
  linewidth      = 1pt,
  frametitlerule = true,
  roundcorner    = 2pt%
}


\newenvironment{CountingDefinition}[2][]{%
   \ifstrempty{#1}%
   {\mdfsetup{%
      frametitle={{\strut ~}}}
   }%
   {\mdfsetup{%
      frametitle={{\strut ~#1}}}%
   }%
   \mdfsetup{
      nobreak                   = true,
     linecolor                 = gray,
    frametitlebackgroundcolor = gray!50,
    style                     = enviStyle
   }
   \begin{mdframed}[]\relax%
   \label{#2}}{\end{mdframed}}
   
   
   
   

\begin{document}

\section*{Summary: Lecture 4}

Summary for the chapter \textit{7.3} from page 150 on. \cite{book}

\begin{CountingDefinition}[Nondeterministic Turing Machine]{def:validLabelPlacement}
A nondeterministic Turing machine (\textit{NTM}) has states, which have more than one possible next state for an action. The states are not completely determined by its action and the current symbol it sees, (unlike a deterministic Turing Machine).

NTMs are for example used in thought experiments. One of the most important problems in is the P versus NP problem: How difficult it is to simulate nondeterministic computation with a deterministic computer? \cite{JE, book}
\end{CountingDefinition}

\subsection*{Asymmetry of non-deterministism}


\textbf{Asymmetry of nondeterministic acceptance:}
\begin{itemize}
\item Example: find out if a formula $\varphi$ is satisfiable ($\varphi \in SAT$): 
\begin{itemize}
\item choose truth values for the variables nondeterministically
\item check if they make $\varphi$ become true
\end{itemize}
\item this approach seems to be unpractical so check whether $\varphi$ is not satisfiable ($\varphi \in \overline{SAT}$)
\item Question whether NP $=$ coNP is a statement about \textit{all} options
\end{itemize}

\textbf{Asymmetry of nondeterministic space:}
\begin{itemize}
\item Example: REACHABILITY $\in$ NL
\begin{itemize}
\item starting at start node 1
\item algorithm walks through nondeterminstically chosen edges $ \leq n$ times
\item only current position is remembered ($\log n$ space)
\item accepts if current node is node $n$
\end{itemize}
\item this approach seems to be unpractical so check if node $n$ is \textit{not} reachable from node 1
\end{itemize}


\begin{CountingDefinition}[$\log n$ space]{def:validLabelPlacement}
A graph algorithm using $O(\log n)$ space stores a fixed number of pointers, independent of $n$, and manipulates them in some way. 
\cite{unknown}
\end{CountingDefinition}

%\begin{CountingDefinition}[$\log n$ time]{def:validLabelPlacement}
%$O(\log N)$: time grows linearly while $n$ grows exponentially. 
%\end{CountingDefinition}




%to show that it is impossible to ... in SPACE was unsolved until the 80s \\
%$h$ for function (yes or no or $h$?) \\
%$h$ is yes \\
%everything that fails stops in stae with no \\


\color{red} TODO \\
\color{black}
\color{violet} Questions: \\
% Why is the current position remembering in $\log n$ space?
\color{black}


\section*{Immerman-Szelepsc√®nyi}

how many distinct nodes can be reached in a graph if you start from a graph $x$ \\
$s(0)$ will contain node 1 and $s(1)$ will contain all neighbours of 1 \\
we will have actual names \\
4 nested for loops and algorithm happens in the middle \\
outer for loop: \\
computes number of nodes reachable from initial node (for $k$ steps with $k$ as the interative thingy in the for loop) \\
in each step we override the previous set with the next one because we only have limited space \\
second loop: \\
we get how far we got in the previous steps and sum up how far we can get (because we can get previous set size?) \\
third loop: \\
the actual magic happens here: checking something \\
Aux sounds like a port for headphones \\
return no when all guesses were correct? we remember solution that we were supposed to reach beforehand \\
it requires thinking \\
we cant even mark nodes (would use linear space) but with determinism we get it into $\log n$ (?) \\
% U E A I O
Algorithm (2) slides seems to be important

\color{red} TODO \\
\color{black}
\color{violet} Questions:
\color{black}


\section*{REACHABILITY $\in$ NL}
NL $=$ nondeterministic logarithmic space \\
little bit of stuff between log n and constand but no interesting stuff \\

\color{red} TODO \\
\color{black}
\color{violet} Questions:
\color{black}






\newpage

\printbibliography




\end{document}