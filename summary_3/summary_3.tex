\documentclass[a4]{scrartcl}

% \usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{scrlayer-scrpage}
\usepackage{float}
\pagestyle{scrheadings}
\usepackage{xcolor}
\clearscrheadfoot

\usepackage[backend=biber, maxbibnames=99]{biblatex}
\addbibresource{references.bib}

\setlength{\parindent}{0cm}


\geometry{
  paper=a4paper, % Change to letterpaper for US letter
  top=2cm, % Top margin
  bottom=1.5cm, % Bottom margin
  left=2cm, % Left margin
  right=3cm, % Right margin
}

\ohead{\\
Pina Kolling\\
piko0011}

\begin{document}


%-------------------------------------------------------------------




\section*{Summary: Lecture 3}

Summary for the chapter \textit{7.5} until page 150. \cite{book}

%-------------------------------------------------------------------



\subsection*{Background knowledge}

The P vs. NP problem is an unsolved problem in complexity theory.
Mathematical problems which are solved by a computer are classified as P or NP problems: All problems that can be solved efficiently by a computer belong to the class P. In the case of NP problems it is unknown whether they can be solved efficiently or not. In this context, efficient means that the required computing time of a solution algorithm grows at most polynomially (e.g. quadratically) with increasing complexity. The only thing that is currently clear is that a correct solution to an NP problem can be checked for correctness in polynomial time. 

Developing an algorithm for an NP problem is usually very difficult. Computer scientists and mathematicians do not only try to work out effective algorithms, they also try to determine whether P = NP. In other words, they are trying to find out whether P and NP are really different problem classes or whether it is possible to solve NP problems in polynomial time as well. Scientists all over the world are trying to prove that P != NP. 

The reason why experts wish NP problems to remain almost unsolvable is called cryptography. Unlike many other fields, complexity in cryptography is not only desirable, but necessary. It is important to know that most encryption methods used today are based solely on the fact that the effort to \textit{guess} the key is too high. The problem of \textit{guessing} is therefore an NP problem. Not only theoretically, but also practically, the proof of the solvability of NP problems means the end of all currently used encryption methods.

But there is still hope for cryptography. The NP problem has often been supposedly solved. Both P = NP and P != NP have been attempted to be proven many times. It turned out that every single solution and every single proof attempt so far turned out to be wrong or incomprehensible. \cite{DD, book}



%-------------------------------------------------------------------



\subsection*{Basic relations between complexity classes}


The hierarchy theorem shows how deterministic classes of the same kind (time or space) relate to each other.
Here are the relationships between classes of a different kind exmined: P and NP.


\color{red} TODO
\color{black}

\color{violet} Questions:
\color{black}






%-------------------------------------------------------------------
\subsection*{Deterministic space includes nondeterministic time}
NTIME$(f(n)) \subseteq$ SPACE$(f(n)^2)$ \\
$d$ choices in every step (in $TM$): $1,...,d$ \\
fill something with $1$ in first step \\
second step: simulate nondeterminstic $TM$ \\
pick something and simulate it? % he is drawing boxes on the board...
Until we get to $d$ because we increment by $1$ in each step. \\



\color{red} TODO
\color{black}

\color{violet} Questions:
\color{black}





%-------------------------------------------------------------------
\subsection*{The reachability method}
graphs/graph edges are constructed \\
$M$ empties the tape and puts all the heads to the start \\
there is only a single node that is accepting \\



\color{red} TODO
\color{black}

\color{violet} Questions:
\color{black}



%-------------------------------------------------------------------
\subsection*{Savitch's theorem}
complexit function is at least $\log n$ \\
we are doing an intuitive sketch now \\
this theorem grabs some internal node $k$, check recursively if there is a path from $1$ to $k$ and from $k$ to $n$ \\
test if path from $1$ to $k$ with picking a midpoint again... \\
we can have $\log n$ many segments to work on \\
PATH(startnode, endnode, pathlength) checks if there is a path from startnode to endnode with the length pathlength (?) \\



\color{red} TODO
\color{black}

\color{violet} Questions:
\color{black}



%-------------------------------------------------------------------
\subsection*{Analysis}
imagine the graph \\
graph can be too large to construct \\
why does the meaning of $n$ change?



\color{red} TODO
\color{black}

\color{violet} Questions:
\color{black}














%-------------------------------------------------------------------

\newpage

\printbibliography




\end{document}